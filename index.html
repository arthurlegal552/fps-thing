<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Primeira Pessoa - Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            text-shadow: 1px 1px 1px black;
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            text-align: center;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="info">Clique para jogar | WASD para mover | Mouse para olhar</div>
    <div id="blocker">
        <div>
            <p style="font-size: 28px;">Clique aqui para jogar</p>
            Movimento: WASD<br/>
            Pular: Espa√ßo<br/>
            Correr: Shift<br/>
            Olhar: Mouse
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccff);
        scene.fog = new THREE.Fog(0x88ccff, 0, 500);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 1.6;
        scene.add(camera);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.PointerLockControls(camera, document.body);
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('info');

        blocker.addEventListener('click', () => { controls.lock(); });
        controls.addEventListener('lock', () => {
            instructions.style.display = 'block';
            blocker.style.display = 'none';
        });
        controls.addEventListener('unlock', () => {
            instructions.style.display = 'none';
            blocker.style.display = 'block';
        });

        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff);
        directionalLight.position.set(1, 0.75, 0.5).normalize();
        scene.add(directionalLight);

        const floorGeometry = new THREE.PlaneGeometry(100, 100, 10, 10);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x3a7e3a, roughness: 0.8 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
        const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xff6600 });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.set(0, 1, -5);
        cube.castShadow = true;
        scene.add(cube);

        const gravity = 0.2;
        const jumpForce = 0.35;
        const moveSpeed = { normal: 0.2, running: 0.4 };
        
        const playerState = {
            velocityY: 0,
            isGrounded: false,
            moveSpeed: moveSpeed.normal,
            canJump: true
        };

        const keyStates = {};

        document.addEventListener('keydown', (event) => {
            keyStates[event.code] = true;
            if (event.code === 'ShiftLeft') playerState.moveSpeed = moveSpeed.running;
            if (event.code === 'Space' && playerState.canJump && playerState.isGrounded) {
                playerState.velocityY = jumpForce;
                playerState.isGrounded = false;
                playerState.canJump = false;
            }
        });

        document.addEventListener('keyup', (event) => {
            keyStates[event.code] = false;
            if (event.code === 'ShiftLeft') playerState.moveSpeed = moveSpeed.normal;
            if (event.code === 'Space') playerState.canJump = true;
        });

        let mixer;

    const loader = new THREE.GLTFLoader();
    loader.load('fps_pistol_animations.glb', function(gltf) {
        const model = gltf.scene;
        model.position.set(0.2, -0.3, -0.5);
        model.scale.set(0.2, 0.2, 0.2);
        model.rotation.set(THREE.MathUtils.degToRad(0), 45, 0);
        camera.add(model);

        mixer = new THREE.AnimationMixer(model);
        const clip = THREE.AnimationClip.findByName(gltf.animations, 'Armature|FPS_Pistol_Fire') || gltf.animations[0];
        const action = mixer.clipAction(clip);
        action.play();
        action.loop = THREE.LoopRepeat;
    }, undefined, function(error) {
        console.error('Erro ao carregar o modelo:', error);
    });

        function animate() {
            requestAnimationFrame(animate);

            if (controls.isLocked) {
                const actualSpeed = playerState.moveSpeed;
                if (keyStates['KeyW']) controls.moveForward(actualSpeed);
                if (keyStates['KeyS']) controls.moveForward(-actualSpeed);
                if (keyStates['KeyA']) controls.moveRight(-actualSpeed);
                if (keyStates['KeyD']) controls.moveRight(actualSpeed);

                camera.position.y += playerState.velocityY;
                playerState.velocityY -= gravity * 0.01;

                if (camera.position.y <= 1.6) {
                    camera.position.y = 1.6;
                    playerState.velocityY = 0;
                    playerState.isGrounded = true;
                }
            }

            if (mixer) mixer.update(0.01);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
